'use strict';

var through = require('through');
var topojson = require('topojson');
var merge = require('lodash.merge');

var featureTransform = require('./feature-transform');
var stylize = require('./stylize');
var collector = require('./collector');

function decodeFeatures (featureCollection, codesStr, properties) {
  var features = [];

  if (featureCollection !== undefined && codesStr) {
    features = codesStr
        .split(' ')
        .map(function (code) {

          var feature = featureTransform.decodify(featureCollection, code, properties);
          if (feature === undefined) {
            console.warn('Could not find feature matching code "' + code + '". It will be omitted.');
          }
          return feature;
        })
        .filter(function(feature) {
          return feature !== undefined;
        });
  }

  return features;
}

function stream(opts) {
  opts = normalize(opts);
  var countyFeatureCollection = opts.counties;
  var zoneFeatureCollection = opts.zones;


  if (countyFeatureCollection === undefined) {
    var countyTopo = require('../data/us-counties-10m-topo');
    countyFeatureCollection = topojson.feature(countyTopo, countyTopo.objects.counties);
  }

  function write(alert) {

    //hacking this to generate a multipolygon for each alert, 
    //instead of a featurecollection with redundant properties

    var properties = alert;

    if (opts.stylize) {
      var style = stylize.style(alert);
      alert = merge(alert, style);
    }

    var coordinates = [];

 

    if (alert.polygon) {
  
      //features.push(featureTransform.polygonize(alert.polygon, properties));
      var f = featureTransform.polygonize(alert.polygon, properties);

      coordinates.push(f.geometry.coordinates);
    } else {


      var counties = decodeFeatures(countyFeatureCollection, alert.geocode.FIPS6, properties);
  

      var c = [];
      counties.forEach(function(county) {
        console.log(county.geometry.type);

        if (county.geometry.type == 'MultiPolygon') {
          county.geometry.coordinates[0].forEach(function(polygon) {
            c.push([polygon]);
            console.log(polygon);
          })
        } else {
          console.log(county.geometry.coordinates);
          c.push(county.geometry.coordinates);
        }
        
      })




      coordinates = c;

      //features = features.concat(counties);

      // var zones = decodeFeatures(zoneFeatureCollection, alert.geocode.FIPS6, properties);
      // features = features.concat(zones);
    }

    //console.log(features);

    var fc = {
      type: "Feature",
      properties: properties,
      geometry: {
        type:"MultiPolygon",
        coordinates:coordinates
      }

    };

    this.queue(fc);
  }

  return through(write);
}

function normalize(opts) {
  var normalized = opts || {};

  if (normalized.stylize === undefined) {
    normalized.stylize = true;
  }

  return normalized;
}


module.exports = {
  stream: stream,
  collect: collector.collect,
};
